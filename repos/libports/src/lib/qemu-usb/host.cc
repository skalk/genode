/**
 * \brief  USB session back end
 * \author Josef Soentgen
 * \author Sebastian Sumpf
 * \author Stefan Kalkowski
 * \date   2015-12-18
 */

#include <base/allocator_avl.h>
#include <base/log.h>
#include <base/attached_rom_dataspace.h>
#include <usb_session/device.h>
#include <util/list_model.h>
#include <util/xml_node.h>

#include <extern_c_begin.h>
#include <qemu_emul.h>
#include <hw/usb.h>
#include <desc.h>
#include <extern_c_end.h>

using namespace Genode;

Mutex _mutex;

static bool const verbose_host = false;

using handle_t = unsigned long;

class Device;
class Interface;
class Endpoint;


class Urb : Usb::Endpoint, public Usb::Interface::Urb
{
	private:

		friend class ::Interface;
		using Pdesc = Usb::Interface::Packet_descriptor;

		static Pdesc::Type _type(uint8_t t)
		{
			switch(t) {
				case USB_ENDPOINT_XFER_BULK:  return Pdesc::BULK;
				case USB_ENDPOINT_XFER_INT:   return Pdesc::IRQ;
				case USB_ENDPOINT_XFER_ISOC:  return Pdesc::ISOC;
				default:                      return Pdesc::FLUSH;
			};
			return Pdesc::FLUSH;
		}

		::Endpoint       &_endpoint;
		USBPacket * const _packet   { nullptr };
		bool              _canceled { false   };

	public:

		Urb(::Interface &iface,
		    ::Endpoint  &endp,
		    uint8_t      type,
		    size_t       size,
		    USBPacket   *packet);

		Urb(::Interface &iface,
		    ::Endpoint  &endp,
		    uint8_t      type,
		    size_t       size,
		    uint32_t     isoc_packets);

		bool isoc() const { return Usb::Interface::Urb::_type == Pdesc::ISOC; }
		void cancel() { _canceled = true; }

		size_t read_cache(Byte_range_ptr &dst);
		void   write_cache(Const_byte_range_ptr const &src);
		void   destroy();
};


class Isoc_cache
{
	public:

		enum { PACKETS_PER_URB = 32, URBS = 4 };

	private:

		::Interface   &_iface;
		Endpoint      &_ep;
		Allocator     &_alloc;
		uint8_t        _read  { 0 };
		uint8_t        _wrote { 0 };
		unsigned char *_buffer;

		Constructible<Urb> _urbs[URBS];

		void _new_urb();

		uint8_t _level() const;

		void _copy_to_host(USBPacket *p);
		void _copy_to_guest(USBPacket *p);

	public:

		Isoc_cache(::Interface &iface, Endpoint &ep, Allocator &alloc);

		void   handle(USBPacket *p);
		size_t read(Byte_range_ptr &dst);
		void   write(Const_byte_range_ptr const &src);
		void   destroy(Urb * urb);
		void   flush();
};


class Endpoint : public List_model<Endpoint>::Element
{
	private:

		uint8_t const             _address;
		uint8_t const             _attributes;
		uint8_t const             _max_packet_size;
		Constructible<Isoc_cache> _isoc_cache { };

	public:

		Endpoint(Xml_node const &n, Allocator &alloc, ::Interface &iface)
		:
			_address(n.attribute_value<uint8_t>("address", 0xff)),
			_attributes(n.attribute_value<uint8_t>("attributes", 0xff)),
			_max_packet_size(n.attribute_value<uint8_t>("max_packet_size", 0))
		{
			if ((_attributes&0x3) == Usb::Endpoint::ISOC)
				_isoc_cache.construct(iface, *this, alloc);
		}

		uint8_t address()         const { return _address; }
		uint8_t attributes()      const { return _attributes; }
		uint8_t max_packet_size() const { return _max_packet_size; }

		bool matches(Xml_node const &node) const {
			return address() == node.attribute_value<uint8_t>("address", 0xff); }

		static bool type_matches(Xml_node const &node) {
			return node.has_type("endpoint"); }

		bool in() const { return address() & (1<<7); }

		void handle_isoc_packet(USBPacket *p) {
			if (_isoc_cache.constructed()) _isoc_cache->handle(p); }

		size_t read_cache(Byte_range_ptr &dst) {
			return (_isoc_cache.constructed()) ? _isoc_cache->read(dst) : 0; }

		void write_cache(Const_byte_range_ptr const &src) {
			if (_isoc_cache.constructed()) _isoc_cache->write(src); }

		void destroy_urb(Urb * urb) {
			if (_isoc_cache.constructed()) _isoc_cache->destroy(urb); }

		void flush() {
			if (_isoc_cache.constructed()) _isoc_cache->flush(); }
};


class Interface : public List_model<::Interface>::Element
{
	private:

		friend class Urb;

		Device                       &_device;
		Constructible<Usb::Interface> _iface {};
		List_model<Endpoint>          _endpoints {};
		uint8_t const                 _number;
		uint8_t const                 _alt_setting;
		bool                          _active;
		size_t                        _buf_size { 4096 * 8 };

		Usb::Interface &_session();

	public:

		Interface(Device &device, Xml_node const &n)
		:
			_device(device),
			_number(n.attribute_value<uint8_t>("number", 0xff)),
			_alt_setting(n.attribute_value<uint8_t>("alt_setting", 0xff)),
			_active(n.attribute_value("active", false)) {}

		~Interface()
		{
			if (_iface.constructed())
				_iface->dissolve_all_urbs<Urb>([] (Urb&) {});
		}

		uint8_t number()      const { return _number; };
		uint8_t alt_setting() const { return _alt_setting; };
		bool    active()      const { return _active; }

		bool matches(Xml_node const &n) const
		{
			uint8_t nr  = n.attribute_value<uint8_t>("number", 0xff);
			uint8_t alt = n.attribute_value<uint8_t>("alt_setting", 0xff);
			return _number == nr && _alt_setting == alt;
		}

		static bool type_matches(Xml_node const &node) {
			return node.has_type("interface"); }

		void update(Allocator &alloc, Xml_node const &node)
		{
			_active = node.attribute_value("active", false);
			_endpoints.update_from_xml(node,

				/* create */
				[&] (Xml_node const &node) -> Endpoint & {
					return *new (alloc) Endpoint(node, alloc, *this); },

				/* destroy */
				[&] (Endpoint &endp) {
					destroy(alloc, &endp); },

				/* update */
				[&] (Endpoint &, Xml_node const &) { }
			);
		}

		void update_urbs();

		template <typename FN>
		void with_endpoint(uint8_t index, FN const &fn)
		{
			_endpoints.for_each([&] (Endpoint &endp) {
				if (endp.address() == index) fn(endp);
			});
		}

		template <typename FN>
		void for_each_endpoint(FN const &fn) {
			_endpoints.for_each([&] (Endpoint &endp) { fn(endp); }); }
};


class Device : public List_model<Device>::Element
{
	public:

		using Name  = String<64>;
		using Speed = String<32>;

	private:

		Name                      const _name;
		Speed                     const _speed;
		Id_space<Device>::Element const _elem;
		Usb::Device                     _device;
		Signal_context_capability       _sigh_cap;
		USBHostDevice                  *_qemu_device { nullptr };
		List_model<::Interface>         _ifaces {};

		/**
		 * Noncopyable
		 */
		Device(Device const &);
		Device &operator = (Device const &);

	public:

		struct Urb : Usb::Device::Urb
		{
			using Request_type =
				Usb::Device::Packet_descriptor::Request_type::access_t;

			USBPacket * const _packet;

			Urb(Device    &device,
			    uint8_t    request,
			    uint8_t    request_type,
			    uint16_t   value,
			    uint16_t   index,
			    size_t     size,
			    USBPacket *packet)
			:
				Usb::Device::Urb(device._device, request,
				                 (Request_type)request_type,
				                 value, index, size),
				_packet(packet) {}
		};

		Device(Name                     &name,
		       Speed                    &speed,
		       Usb::Connection          &usb,
		       Allocator                &alloc,
		       Region_map               &rm,
		       Id_space<Device>         &space,
		       Signal_context_capability cap)
		:
			_name(name),
			_speed(speed),
			_elem(*this, space),
			_device(usb, alloc, rm, name),
			_sigh_cap(cap)
		{
			_device.sigh(_sigh_cap);
		}

		~Device() {
			_device.dissolve_all_urbs<Urb>([] (Urb&) {}); }

		Usb::Device &session() { return _device; }

		Name name() { return _name; }

		int speed()
		{
			if (_speed == "low")            return USB_SPEED_LOW;
			if (_speed == "full")           return USB_SPEED_FULL;
			if (_speed == "high")           return USB_SPEED_HIGH;
			if (_speed == "super")          return USB_SPEED_SUPER;
			if (_speed == "super_plus")     return USB_SPEED_SUPER;
			if (_speed == "super_plus_2x2") return USB_SPEED_SUPER;
			return USB_SPEED_FULL;
		}

		Signal_context_capability sigh_cap() { return _sigh_cap; }

		handle_t handle() const { return _elem.id().value; }

		void  qemu_device(USBHostDevice *dev) { _qemu_device = dev;  }
		USBHostDevice* qemu_device() { return _qemu_device; }

		bool matches(Xml_node const &node) const {
			return _name == node.attribute_value("name", Name()); }

		static bool type_matches(Xml_node const &node) {
			return node.has_type("device"); }

		void update(Allocator &alloc, Xml_node const &node)
		{
			Xml_node active_config = node;

			node.for_each_sub_node("config", [&] (Xml_node const &node) {
				if (node.attribute_value("active", false))
					active_config = node;
			});

			_ifaces.update_from_xml(active_config,

				/* create */
				[&] (Xml_node const &node) -> ::Interface & {
					return *new (alloc) ::Interface(*this, node); },

				/* destroy */
				[&] (::Interface &iface) {
					iface.update(alloc, Xml_node("<empty/>"));
					destroy(alloc, &iface); },

				/* update */
				[&] (::Interface &iface, Xml_node const &node) {
					iface.update(alloc, node); }
			);
		}

		void update_urbs();

		template <typename FN>
		void with_active_interfaces(FN const &fn)
		{
			_ifaces.for_each([&] (::Interface &iface) {
				if (iface.active()) fn(iface); });
		}
};


struct Session
{
	Env                      &_env;
	Allocator                &_alloc;
	Signal_context_capability _handler_cap;
	Usb::Connection           _usb { _env };
	List_model<Device>        _model {};
	Id_space<Device>          _space {};

	Session(Env &env, Allocator &alloc, Signal_context_capability cap)
	:
		_env(env), _alloc(alloc), _handler_cap(cap)
	{
		_usb.sigh(cap);
	}

	~Session() {
		_model.for_each([&] (Device &dev) { destroy(_alloc, &dev); }); }

	void update()
	{
		_usb.with_xml([&] (Xml_node node) {
			_model.update_from_xml(node,

				/* create */
				[&] (Xml_node const &node) -> Device &
				{
					Device::Name name =
						node.attribute_value("name", Device::Name());
					Device::Speed speed =
						node.attribute_value("speed", Device::Speed());
					Device &dev = *new (_alloc)
						Device(name, speed, _usb, _alloc, _env.rm(),
						       _space, _handler_cap);
					return dev;
				},

				/* destroy */
				[&] (Device &dev)
				{
					if (dev.qemu_device())
						remove_usbdevice(dev.qemu_device());
					dev.update(_alloc, Xml_node("<empty/>"));
					destroy(_alloc, &dev);
				},

				/* update */
				[&] (Device &dev, Xml_node const &node)
				{
					dev.update(_alloc, node);
				}
			);
		});
		/* add new devices for C-API client after it got successfully added */
		_model.for_each([&] (Device &dev) {
			if (!dev.qemu_device())
				dev.qemu_device(create_usbdevice((void*)dev.handle(),
				                                 dev.speed()));
		});
	}
};


Urb::Urb(::Interface &iface,
         ::Endpoint  &endp,
         uint8_t      type,
         size_t       size,
         USBPacket   *packet)
:
	Usb::Endpoint(endp.address(), endp.attributes()),
	Usb::Interface::Urb(iface._session(), *this,
	                    _type(type), size),
	_endpoint(endp), _packet(packet) {}


Urb::Urb(::Interface &iface,
         ::Endpoint  &endp,
         uint8_t      type,
         size_t       size,
         uint32_t     isoc_packets)
:
	Usb::Endpoint(endp.address(), endp.attributes()),
	Usb::Interface::Urb(iface._session(), *this,
	                    _type(type), size, isoc_packets),
	_endpoint(endp) {}


size_t Urb::read_cache(Byte_range_ptr &dst)
{
	return _canceled ? 0 : _endpoint.read_cache(dst);
}


void Urb::write_cache(Const_byte_range_ptr const &src)
{
	if (!_canceled) _endpoint.write_cache(src);
}


void Urb::destroy()
{
	_endpoint.destroy_urb(this);
}



uint8_t Isoc_cache::_level() const {
	return (_ep.in()) ? _read-_wrote : _wrote-_read; }


void Isoc_cache::_new_urb()
{
	uint8_t urbs = (_ep.in()) ? URBS : _level() / PACKETS_PER_URB;

	for (unsigned i = 0; urbs && i < URBS; i++) {
		if (_urbs[i].constructed())
			continue;
		_urbs[i].construct(_iface, _ep, USB_ENDPOINT_XFER_ISOC,
		                   _ep.max_packet_size()*PACKETS_PER_URB, PACKETS_PER_URB);
		--urbs;
	}
}


void Isoc_cache::_copy_to_host(USBPacket *p)
{
	size_t size = p->iov.size;

	if (!size || _level() >= URBS*PACKETS_PER_URB) {
		return;
	}

	size_t offset = _wrote++ * _ep.max_packet_size();

	if (size > _ep.max_packet_size()) {
		error("Assumption about QEmu Isochronous packet size is wrong!");
		size = _ep.max_packet_size();
	}

	usb_packet_copy(p, _buffer+offset, size);
}


void Isoc_cache::_copy_to_guest(USBPacket *p)
{
	size_t size = p->iov.size;

	if (!size || !_level())
		return;

	size_t offset = _read++ * _ep.max_packet_size();

	if (size > _ep.max_packet_size()) {
		error("Assumption about QEmu Isochronous packet size is wrong!");
		size = _ep.max_packet_size();
	}

	usb_packet_copy(p, _buffer+offset, size);
}


void Isoc_cache::handle(USBPacket *p)
{
	if (_ep.in()) _copy_to_guest(p);
	else          _copy_to_host(p);
	_new_urb();
	_iface.update_urbs();
}


size_t Isoc_cache::read(Byte_range_ptr &dst)
{
	if (_ep.in())
		return _ep.max_packet_size();

	size_t offset = _read * _ep.max_packet_size();
	_read++;
	Genode::memcpy(dst.start, (void*)(_buffer+offset), _ep.max_packet_size());
	return _ep.max_packet_size();
}


void Isoc_cache::write(Const_byte_range_ptr const &src)
{
	size_t offset = _wrote * _ep.max_packet_size();
	_wrote        += src.num_bytes / _ep.max_packet_size();
	Genode::memcpy((void*)(_buffer+offset), src.start, src.num_bytes);
}


void Isoc_cache::destroy(Urb * urb)
{
	for (unsigned i = 0; i < URBS; i++)
		if (_urbs[i].constructed() && &*_urbs[i] == urb) {
			_urbs[i].destruct();
			return;
		}
	_new_urb();
}


void Isoc_cache::flush()
{
	_read  = 0;
	_wrote = 0;
	for (unsigned i = 0; i < URBS; i++)
		if (_urbs[i].constructed())
			_urbs[i]->cancel();
}


Isoc_cache::Isoc_cache(::Interface &iface, Endpoint &ep, Allocator &alloc)
:
	_iface(iface), _ep(ep), _alloc(alloc),
	_buffer((unsigned char*)_alloc.alloc(256*ep.max_packet_size())) {}


Usb::Interface &::Interface::_session()
{
	if (!_iface.constructed()) {
		_iface.construct(_device.session(),
		                 Usb::Interface::Index{_number, _alt_setting},
		                 _buf_size);
		_iface->sigh(_device.sigh_cap());
	}
	return *_iface;
};


static Constructible<::Session>& _usb_session()
{
	static Constructible<::Session> session {};
	return session;
}


#define USB_HOST_DEVICE(obj) \
        OBJECT_CHECK(USBHostDevice, (obj), TYPE_USB_HOST_DEVICE)


static void usb_host_update_ep(USBDevice *udev)
{
	USBHostDevice *d = USB_HOST_DEVICE(udev);
	handle_t handle = (handle_t)d->data;

	usb_ep_reset(udev);
	_usb_session()->_space.apply<Device>({ handle },
	                                     [&] (Device & device) {
		device.with_active_interfaces([&] (::Interface &iface) {
			iface.for_each_endpoint([&] (Endpoint &endp) {
				int     const pid   = (endp.address() & USB_DIR_IN)
					? USB_TOKEN_IN : USB_TOKEN_OUT;
				int     const ep    = (endp.address() & 0xf);
				uint8_t const type  = (endp.attributes() & 0x3);
				usb_ep_set_max_packet_size(udev, pid, ep, endp.max_packet_size());
				usb_ep_set_type(udev, pid, ep, type);
				usb_ep_set_ifnum(udev, pid, ep, iface.number());
				usb_ep_set_halted(udev, pid, ep, 0);
			});
		});
	});
}


void produce_out_data(USBPacket * const p, Byte_range_ptr &dst)
{
	USBEndpoint *ep   = p  ? p->ep   : nullptr;
	USBDevice   *udev = ep ? ep->dev : nullptr;

	if (!udev) {
		error("cannot produce data for invalid USB Packet");
		return;
	}

	switch (usb_ep_get_type(udev, p->pid, p->ep->nr)) {
	case USB_ENDPOINT_XFER_CONTROL:
		Genode::memcpy(dst.start, udev->data_buf, dst.num_bytes);
		return;
	case USB_ENDPOINT_XFER_BULK:
	case USB_ENDPOINT_XFER_INT:
		usb_packet_copy(p, dst.start, dst.num_bytes);
		break;
	case USB_ENDPOINT_XFER_ISOC:
		error("ISOC produce out");
		break;
	default:
		error("cannot produce data for unknown packet");
	}
}


void consume_in_data(USBPacket * const p, Const_byte_range_ptr const &src)
{
	USBEndpoint *ep   = p  ? p->ep   : nullptr;
	USBDevice   *udev = ep ? ep->dev : nullptr;

	if (!udev) {
		error("cannot consume data of invalid USB Packet");
		return;
	}

	switch (usb_ep_get_type(udev, p->pid, p->ep->nr)) {
	case USB_ENDPOINT_XFER_CONTROL:
		p->actual_length = src.num_bytes;
		Genode::memcpy(udev->data_buf, src.start, src.num_bytes);
		return;
	case USB_ENDPOINT_XFER_BULK:
	case USB_ENDPOINT_XFER_INT:
		/*
		 * unfortunately usb_packet_copy does not provide a signature
		 * for const-access of the source
		 */
		usb_packet_copy(p, const_cast<char*>(src.start), src.num_bytes);
		break;
	default:
		error("cannot consume data of unknown packet");
	}
}


void complete_packet(USBPacket * const p)
{
	USBEndpoint *ep   = p  ? p->ep   : nullptr;
	USBDevice   *udev = ep ? ep->dev : nullptr;

	if (!udev) {
		error("cannot complete invalid USB Packet");
		return;
	}

	switch (usb_ep_get_type(udev, p->pid, p->ep->nr)) {
	case USB_ENDPOINT_XFER_CONTROL:
		p->status = USB_RET_SUCCESS;
		if (udev->setup_buf[1] == USB_REQ_SET_INTERFACE) {
			usb_host_update_devices();
			usb_host_update_ep(udev);
		}
		usb_generic_async_ctrl_complete(udev, p);
		return;
	case USB_ENDPOINT_XFER_BULK:
	case USB_ENDPOINT_XFER_INT:
		p->status = USB_RET_SUCCESS;
		usb_packet_complete(udev, p);
		break;
	default:
		error("cannot produce data for unknown packet");
	}
}


void ::Interface::update_urbs()
{
	if (!_iface.constructed())
		return;

	_iface->update_urbs<Urb>(
		[&] (Urb &urb, Byte_range_ptr &dst) {
			produce_out_data(urb._packet, dst); },
		[&] (Urb &urb, Const_byte_range_ptr const &src) {
			consume_in_data(urb._packet, src); },
		[&] (Urb &urb, uint32_t, Byte_range_ptr &dst) {
			return urb.read_cache(dst); },
		[&] (Urb &urb, uint32_t, Const_byte_range_ptr const &src) {
			urb.write_cache(src); },
		[&] (Urb &urb, Usb::Interface::Packet_descriptor::Return_value)
		{
			if (!urb.isoc()) {
				complete_packet(urb._packet);
				if (_usb_session().constructed())
					destroy(_usb_session()->_alloc, &urb);
			} else
				urb.destroy();
		}
	);
}


void Device::update_urbs()
{
	_device.update_urbs<Urb>(
		[&] (Urb &urb, Byte_range_ptr &dst) {
			produce_out_data(urb._packet, dst); },
		[&] (Urb &urb, Const_byte_range_ptr const &src) {
			consume_in_data(urb._packet, src); },
		[&] (Urb &urb, Usb::Device::Packet_descriptor::Return_value) {
			complete_packet(urb._packet);
			if (_usb_session().constructed())
				destroy(_usb_session()->_alloc, &urb);
		}
	);

	_ifaces.for_each([&] (::Interface &iface) {
		iface.update_urbs(); });
}


extern "C" void usb_host_update_device_transfers()
{
	if (!_usb_session().constructed())
		return;

	_usb_session()->_model.for_each([&] (Device & device) {
		device.update_urbs(); });
}


static void usb_host_realize(USBDevice *udev, Error **errp)
{
	USBHostDevice *d = USB_HOST_DEVICE(udev);
	handle_t handle = (handle_t)d->data;

	udev->flags |= (1 << USB_DEV_FLAG_IS_HOST);
	usb_host_update_ep(udev);
}


static void usb_host_cancel_packet(USBDevice *udev, USBPacket *p)
{
	error(__func__, " ", p, " not implemented yet");
}


static void usb_host_handle_data(USBDevice *udev, USBPacket *p)
{
	USBHostDevice *d = USB_HOST_DEVICE(udev);
	handle_t handle = (handle_t)d->data;
	uint8_t type = usb_ep_get_type(udev, p->pid, p->ep->nr);
	uint8_t ep   = p->ep->nr | ((p->pid == USB_TOKEN_IN) ? USB_DIR_IN : 0);

	_usb_session()->_space.apply<Device>({ handle }, [&] (Device & device) {
		device.with_active_interfaces([&] (::Interface &iface) {
			iface.with_endpoint(ep, [&] (Endpoint &endp) {

				switch (type) {
				case USB_ENDPOINT_XFER_BULK: [[fallthrough]];
				case USB_ENDPOINT_XFER_INT:
					p->status = USB_RET_ASYNC;
					new (_usb_session()->_alloc)
						::Urb(iface, endp, type, usb_packet_size(p), p);
					break;
				case USB_ENDPOINT_XFER_ISOC:
					p->status = USB_RET_SUCCESS;
					endp.handle_isoc_packet(p);
					return;
				default:
					error("not supported data request ", (int)type);
					p->status = USB_RET_NAK;
					return;
				}
			});
			iface.update_urbs();
		});
	});
}


static void usb_host_handle_control(USBDevice *udev, USBPacket *p,
                                    int request, int value, int index,
                                    int length, uint8_t *data)
{
	USBHostDevice *d = USB_HOST_DEVICE(udev);
	handle_t handle = (handle_t)d->data;

	if (verbose_host)
		log("r: ", Hex(request), " v: ", Hex(value), " "
		    "i: ", Hex(index), " length: ", length);

	switch (request) {
	case DeviceOutRequest | USB_REQ_SET_ADDRESS:
		udev->addr = value;
		p->status = USB_RET_SUCCESS;
		return;
	}

	if (udev->speed == USB_SPEED_SUPER &&
		!(udev->port->speedmask & USB_SPEED_MASK_SUPER) &&
		request == 0x8006 && value == 0x100 && index == 0) {
		error("r->usb3ep0quirk = true");
	}

	_usb_session()->_space.apply<Device>({ handle },
	                                     [&] (Device & device) {
		new (_usb_session()->_alloc)
			Device::Urb(device, request & 0xff, (request >> 8) & 0xff,
			            value, index, length, p);
		device.update_urbs();
	});

	p->status = USB_RET_ASYNC;
}


static void usb_host_ep_stopped(USBDevice *udev, USBEndpoint *usb_ep)
{
	USBHostDevice *d = USB_HOST_DEVICE(udev);
	handle_t handle = (handle_t)d->data;
	uint8_t ep = usb_ep->nr | ((usb_ep->pid == USB_TOKEN_IN) ? USB_DIR_IN : 0);

	error(__func__);

	_usb_session()->_space.apply<Device>({ handle }, [&] (Device & device) {
		device.with_active_interfaces([&] (::Interface &iface) {
			iface.with_endpoint(ep, [&] (Endpoint &endp) {
				endp.flush();
			});
		});
	});
}


static Property usb_host_dev_properties[] = {
    DEFINE_PROP_END_OF_LIST(),
};


static void usb_host_class_initfn(ObjectClass *klass, void *data)
{
	DeviceClass *dc = DEVICE_CLASS(klass);
	USBDeviceClass *uc = USB_DEVICE_CLASS(klass);

	uc->realize        = usb_host_realize;
	uc->product_desc   = "USB Host Device";
	uc->cancel_packet  = usb_host_cancel_packet;
	uc->handle_data    = usb_host_handle_data;
	uc->handle_control = usb_host_handle_control;
	uc->ep_stopped     = usb_host_ep_stopped;
	dc->props = usb_host_dev_properties;
}


static TypeInfo usb_host_dev_info;


static void usb_host_register_types(void)
{
	usb_host_dev_info.name          = TYPE_USB_HOST_DEVICE;
	usb_host_dev_info.parent        = TYPE_USB_DEVICE;
	usb_host_dev_info.instance_size = sizeof(USBHostDevice);
	usb_host_dev_info.class_init    = usb_host_class_initfn;

	type_register_static(&usb_host_dev_info);
}


extern "C" void usb_host_update_devices()
{
	if (_usb_session().constructed()) _usb_session()->update();
}


extern "C" void usb_host_destroy() { }


/*
 * Do not use type_init macro because of name mangling
 */
extern "C" void _type_init_usb_host_register_types(Entrypoint *ep,
                                                   Allocator *alloc,
                                                   Env *env)
{
	struct Helper : Signal_handler<Helper>
	{
		Helper(Entrypoint &ep)
		: Signal_handler<Helper>(ep, *this, &Helper::_update) {}

		void _update()
		{
			Mutex::Guard guard(::_mutex);
			usb_host_update_devices();
			usb_host_update_device_transfers();
		}
	};
	static Helper helper(*ep);

	Mutex::Guard guard(::_mutex);
	usb_host_register_types();
	_usb_session().construct(*env, *alloc, helper);
	usb_host_update_devices();
}
